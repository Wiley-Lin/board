<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>UsDone Pro | Smart Scale High-Res</title>
    <style>
        :root {
            --bg: #1a1a1a;
            --panel: #2d2d2d;
            --morandi-green: #8e9775;
            --tool-bg: rgba(45, 45, 45, 0.95);
            --text: #e0e0e0;
        }

        body, html { margin: 0; padding: 0; height: 100%; background: var(--bg); font-family: sans-serif; overflow: hidden; color: var(--text); }

        /* 左側工具列 */
        .side-bar {
            position: absolute; left: 25px; top: 50%; transform: translateY(-50%);
            z-index: 100; background: var(--tool-bg); backdrop-filter: blur(20px);
            padding: 20px 12px; border-radius: 24px; display: flex; flex-direction: column; gap: 18px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5); width: 65px; align-items: center;
            border: 1px solid rgba(255,255,255,0.08);
        }

        .tool-btn {
            width: 44px; height: 44px; border-radius: 12px; border: none; cursor: pointer;
            background: #3d3d3d; transition: 0.25s; display: flex; align-items: center; justify-content: center;
            font-size: 11px; font-weight: bold; color: #aaa;
        }
        .tool-btn.active { background: var(--morandi-green); color: white; transform: scale(1.08); }

        .control-group { display: flex; flex-direction: column; align-items: center; gap: 8px; width: 100%; border-top: 1px solid #444; padding-top: 12px; }
        input[type="color"] { border: none; width: 28px; height: 28px; cursor: pointer; background: none; }
        input[type="range"] { width: 50px; accent-color: var(--morandi-green); }

        /* 頂部操作鈕 */
        .top-bar { position: absolute; top: 25px; right: 30px; display: flex; gap: 12px; z-index: 100; }
        .action-btn {
            padding: 9px 20px; border-radius: 30px; border: none; cursor: pointer;
            font-size: 13px; background: var(--panel); color: #bbb; box-shadow: 0 4px 15px rgba(0,0,0,0.3); transition: 0.2s;
        }
        .action-btn:hover { background: #3d3d3d; color: white; }

        /* 畫布容器 */
        #container { 
            width: 100vw; height: 100vh; 
            display: flex; justify-content: center; align-items: center;
            padding-left: 90px; box-sizing: border-box;
        }

        canvas { 
            background: #ffffff; 
            box-shadow: 0 20px 80px rgba(0,0,0,0.5); 
            border-radius: 4px;
            cursor: crosshair;
        }
    </style>
</head>
<body>

<div class="side-bar">
    <button class="tool-btn active" id="mode-move" onclick="setMode('move')">移動</button>
    <button class="tool-btn" id="mode-rect" onclick="setMode('rect')">框框</button>
    <button class="tool-btn" id="mode-mosaic" onclick="setMode('mosaic')">噴砂</button>
    
    <div class="control-group">
        <input type="color" id="colorPicker" value="#ff0000">
    </div>

    <div class="control-group">
        <input type="range" id="brushSize" min="10" max="120" value="40">
    </div>
</div>

<div class="top-bar">
    <button class="action-btn" onclick="undo()">⤺ 上一步</button>
    <button class="action-btn" onclick="clearBoard()">清空</button>
    <button class="action-btn" onclick="exportImage()" style="background: var(--morandi-green); color: white;">匯出成果</button>
</div>

<div id="container">
    <canvas id="canvas"></canvas>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const colorPicker = document.getElementById('colorPicker');
    const brushSizeInput = document.getElementById('brushSize');

    let mode = 'move';
    let images = []; 
    let history = []; 
    const MAX_HISTORY = 30;

    let selectedItem = null;
    let isDrawing = false;
    let startX, startY;
    let currentSnapshot = null;

    function init() {
        // 為了確保畫質，我們使用較大的內部解析度
        canvas.width = 1920; 
        canvas.height = 1080;
        
        // 開啟高品質渲染設定
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        saveState(); 
        render();
    }

    function setMode(m) {
        mode = m;
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`mode-${m}`).classList.add('active');
        selectedItem = null;
        render();
    }

    function saveState() {
        if (history.length >= MAX_HISTORY) history.shift();
        history.push({
            imagesData: JSON.parse(JSON.stringify(images.map(i => ({ x: i.x, y: i.y, w: i.w, h: i.h })))),
            canvasURL: canvas.toDataURL('image/png', 1.0)
        });
    }

    function undo() {
        if (history.length <= 1) return;
        history.pop();
        const state = history[history.length - 1];
        
        images = images.slice(0, state.imagesData.length);
        state.imagesData.forEach((data, i) => { if (images[i]) Object.assign(images[i], data); });

        const img = new Image();
        img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);
            render();
        };
        img.src = state.canvasURL;
    }

    window.addEventListener('dragover', e => e.preventDefault());
    window.addEventListener('drop', e => {
        e.preventDefault();
        const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
        files.forEach(file => {
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = new Image();
                img.onload = () => {
                    // 智慧縮放邏輯：如果圖片比畫布大，縮小到畫布的 60%
                    const boardLimit = canvas.width * 0.6;
                    let targetW = img.width;
                    let targetH = img.height;

                    if (targetW > boardLimit || targetH > boardLimit) {
                        const ratio = Math.min(boardLimit / targetW, boardLimit / targetH);
                        targetW *= ratio;
                        targetH *= ratio;
                    }

                    images.push({ 
                        img, 
                        x: (canvas.width - targetW) / 2 + (images.length * 20), 
                        y: (canvas.height - targetH) / 2 + (images.length * 20), 
                        w: targetW, 
                        h: targetH, 
                        isDragging: false, 
                        isResizing: false 
                    });
                    render();
                    saveState();
                };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
        });
    });

    function render() {
        if (mode === 'move') {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 如果要完美呈現，這裡應該先貼上「標記層」，再畫上「物件層」
            // 為了不弄複雜，我們採用物件移動時清空背景的邏輯
            images.forEach(item => {
                ctx.drawImage(item.img, item.x, item.y, item.w, item.h);
                if (item === selectedItem) {
                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = varColor('--morandi-green');
                    ctx.lineWidth = 2;
                    ctx.strokeRect(item.x, item.y, item.w, item.h);
                    ctx.setLineDash([]);
                    ctx.fillStyle = varColor('--morandi-green');
                    ctx.fillRect(item.x + item.w - 15, item.y + item.h - 15, 15, 15);
                }
            });
        }
    }

    function varColor(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

    function getMouse(e) {
        const r = canvas.getBoundingClientRect();
        return { 
            x: (e.clientX - r.left) * (canvas.width / r.width), 
            y: (e.clientY - r.top) * (canvas.height / r.height) 
        };
    }

    canvas.onmousedown = (e) => {
        const { x, y } = getMouse(e);
        if (mode === 'move') {
            selectedItem = null;
            for (let i = images.length - 1; i >= 0; i--) {
                const img = images[i];
                if (x > img.x + img.w - 25 && x < img.x + img.w + 5 && y > img.y + img.h - 25 && y < img.y + img.h + 5) {
                    img.isResizing = true;
                    selectedItem = img;
                    break;
                }
                if (x > img.x && x < img.x + img.w && y > img.y && y < img.y + img.h) {
                    img.isDragging = true;
                    selectedItem = img;
                    images.push(images.splice(i, 1)[0]);
                    break;
                }
            }
        } else {
            isDrawing = true;
            startX = x; startY = y;
            currentSnapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
        render();
    };

    canvas.onmousemove = (e) => {
        const { x, y } = getMouse(e);
        if (mode === 'move' && selectedItem) {
            if (selectedItem.isDragging) {
                selectedItem.x = x - selectedItem.w / 2;
                selectedItem.y = y - selectedItem.h / 2;
            } else if (selectedItem.isResizing) {
                selectedItem.w = Math.max(40, x - selectedItem.x);
                selectedItem.h = Math.max(40, y - selectedItem.y);
            }
            render();
        } else if (isDrawing) {
            if (mode === 'rect') {
                ctx.putImageData(currentSnapshot, 0, 0);
                ctx.strokeStyle = colorPicker.value;
                ctx.lineWidth = 4;
                ctx.strokeRect(startX, startY, x - startX, y - startY);
            } else if (mode === 'mosaic') {
                applyBrush(x, y);
            }
        }
    };

    canvas.onmouseup = () => {
        if (isDrawing || (selectedItem && (selectedItem.isDragging || selectedItem.isResizing))) saveState();
        isDrawing = false;
        if (selectedItem) {
            selectedItem.isDragging = false;
            selectedItem.isResizing = false;
        }
    };

    function applyBrush(x, y) {
        const size = parseInt(brushSizeInput.value);
        const m = 12; // 調整這裡可改變馬賽克精細度
        const l = x - size/2, t = y - size/2;
        for(let i=0; i<size; i+=m) {
            for(let j=0; j<size; j+=m) {
                try {
                    const p = ctx.getImageData(l+i, t+j, 1, 1).data;
                    ctx.fillStyle = `rgb(${p[0]},${p[1]},${p[2]})`;
                    ctx.fillRect(l+i, t+j, m, m);
                } catch(e) {}
            }
        }
    }

    window.onkeydown = e => { if((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); } };

    function clearBoard() { images = []; ctx.fillStyle = "#ffffff"; ctx.fillRect(0, 0, canvas.width, canvas.height); saveState(); render(); }
    function exportImage() {
        const link = document.createElement('a');
        link.download = 'UsDone-HighRes.png';
        link.href = canvas.toDataURL('image/png', 1.0);
        link.click();
    }

    init();
</script>
</body>
</html>
